/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2018 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include <RixProjection.h>
#include <RixIntegrator.h>
#include <RixShadingUtils.h>

// This plugin reimplements the standard perspective projection.  It shows
// the details of turning screen and aperture samples into rays (complete
// with derivatives) that are exactly identical to those from the built-in
// perspective projection.  It's meant to provide a good base for tweaking.

const static RtUString US_FOV("fov");
const static RtUString US_FSTOP("fStop");
const static RtUString US_FOCALLENGTH("focalLength");
const static RtUString US_FOCALDISTANCE("focalDistance");
const static RtUString US_FOCALDISTANCERIGHT("focalDistanceRight");
const static RtUString US_FOCALDISTANCESPLIT("focalDistanceSplit");
const static RtUString US_FOCALDISTANCEEDGE("focalDistanceEdge");
const static RtUString US_FOCALDISTANCESHIFT("focalDistanceShift");

class WillPerspective : public RixProjection
{
public:
    
    WillPerspective(
        RixContext &ctx,
        RtUString const handle,
        RixParameterList const* parms);
    
    ~WillPerspective() override;

    void RenderBegin(RixContext& ctx, RixProjectionEnvironment const& env,
                 RixParameterList const* parm) override;

    RixSCDetail GetProperty(
        ProjectionProperty property,
        void const** result) const override
    {
        switch (property)
        {
            case k_DicingHint:
                *result = &dicingHint;
                return k_RixSCUniform;
                break;
            case k_FieldOfView:
                *result = &fieldOfView;
                return k_RixSCUniform;
                break;
            case k_FStop:
                *result = &fStop;
                return k_RixSCUniform;
                break;
            case k_FocalLength:
                *result = &focalLength;
                return k_RixSCUniform;
                break;
            case k_FocalDistance:
                *result = &focalDistance;
                return k_RixSCUniform;
                break;
            default:
                return k_RixSCInvalidDetail;
        }
    }

    void Project(
        RixProjectionContext& pCtx ) override;

private:

    DicingHint const dicingHint;
    RtUString m_handle;
    RtFloat fStop;
    RtFloat focalLength;
    RtFloat focalDistance;
    RtFloat focalDistanceRight;
    RtFloat focalDistanceSplit;
    RtFloat focalDistanceEdge;
    RtFloat focalDistanceShift;
    RtFloat lensRadius;
    RtFloat xyStep;
    RtFloat fieldOfView;
    RtFloat zoom;
    RtFloat spread;
};


WillPerspective::WillPerspective(
    RixContext& ctx,
    RtUString const handle,
    RixParameterList const* params)
    : dicingHint(k_Perspective),
      m_handle(handle)
{
    PIXAR_ARGUSED(ctx);
    PIXAR_ARGUSED(params);
}

void WillPerspective::RenderBegin(
    RixContext& ctx,
    RixProjectionEnvironment const& env,
    RixParameterList const* parms)
{
    PIXAR_ARGUSED(ctx);
    PIXAR_ARGUSED(parms);

    float screenWidth = env.screenWindowRight - env.screenWindowLeft;
    float screenHeight = env.screenWindowTop - env.screenWindowBottom;
    if ( screenWidth == 0.0f || screenHeight == 0.0f )
    {
        float aspect = env.width * env.pixelAspectRatio / env.height;
        screenWidth = std::max( 2.0f, 2.0f * aspect );
        screenHeight = std::max( 2.0f, 2.0f / aspect );
    }
    float xStep = 0.25f * screenWidth / env.width;
    float yStep = 0.25f * screenHeight / env.height;
    xyStep = std::max( xStep, yStep );

    fieldOfView = 90.0f;
    fStop = 16;
    focalLength = 0.0f;
    focalDistance = 1.0f;
    focalDistanceRight = 1.0f;
    focalDistanceSplit = 0.0f;
    focalDistanceEdge = 0.01f;
    focalDistanceShift = 0.00f;

    RtInt paramId;
    if ( parms->GetParamId(US_FOV, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &fieldOfView );
    if ( parms->GetParamId(US_FSTOP, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &fStop );
    if ( parms->GetParamId(US_FOCALLENGTH, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &focalLength );
    if ( parms->GetParamId(US_FOCALDISTANCE, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &focalDistance );
    if ( parms->GetParamId(US_FOCALDISTANCERIGHT, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &focalDistanceRight );
    if ( parms->GetParamId(US_FOCALDISTANCESPLIT, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &focalDistanceSplit );  
    if ( parms->GetParamId(US_FOCALDISTANCESHIFT, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &focalDistanceShift );      
    zoom = tanf( 0.5f * fieldOfView * F_DEGTORAD );
    spread = atanf( zoom * xyStep );
    lensRadius = 0.5f * focalLength / fStop;
}


WillPerspective::~WillPerspective()
{
}


void WillPerspective::Project(RixProjectionContext& pCtx )
{
    for ( int index = 0; index < pCtx.numRays; ++index )
    {
        RtPoint2 const& screen( pCtx.screen[ index ] );
        RtPoint2 const& aperture( pCtx.aperture[ index ] );
        RtRayGeometry &ray( pCtx.rays[ index ] );

        float adjFocalDistance = 0.0f;
        float finalFocalDistance = 0.0f;
        
        adjFocalDistance = RixLinearStep(focalDistanceSplit - focalDistanceEdge, focalDistanceSplit + focalDistanceEdge, screen.x);
        finalFocalDistance = RixMix (focalDistance, focalDistanceRight, adjFocalDistance);

        // shift ray origin by edge of diopter
        ray.origin = RtPoint3(
            //aperture.x * lensRadius,
            RixMix (aperture.x * lensRadius,(focalDistanceShift + aperture.x * lensRadius), adjFocalDistance),
            aperture.y * lensRadius,
            0.0f );
                
        ray.direction = RtVector3(
                screen.x * zoom * finalFocalDistance - RixMix (ray.origin.x,(focalDistanceShift + ray.origin.x), adjFocalDistance),
                screen.y * zoom * finalFocalDistance - ray.origin.y,
                finalFocalDistance );
       
        ray.direction.Normalize();
        ray.originRadius = 0.0f;
        ray.raySpread = spread * ray.direction.z;
    }
}

// ===============================================================

class WillPerspectiveFactory : public RixProjectionFactory
{
public:

    WillPerspectiveFactory() {};

    int Init(RixContext& ctx, RtUString const pluginPath) override
    {
        PIXAR_ARGUSED(ctx);
        PIXAR_ARGUSED(pluginPath);

        return 0;
    }

    void Finalize(RixContext& ctx) override
    {
        PIXAR_ARGUSED(ctx);
    }

    RixSCParamInfo const* GetParamTable() override;

    void Synchronize(
        RixContext&,
        RixSCSyncMsg,
        RixParameterList const*) override
    {
    }

    RixProjection* CreateProjection(
        RixContext& ctx,
        RtUString const handle,
        RixParameterList const* pList) override;

    void DestroyProjection(RixProjection const* projection) override;
};


RixSCParamInfo const* WillPerspectiveFactory::GetParamTable()
{
    static RixSCParamInfo s_ptable[] =
    {
        RixSCParamInfo(US_FOV, k_RixSCFloat ),
        RixSCParamInfo(US_FSTOP, k_RixSCFloat ),
        RixSCParamInfo(US_FOCALLENGTH, k_RixSCFloat ),
        RixSCParamInfo(US_FOCALDISTANCE, k_RixSCFloat ),
        RixSCParamInfo(US_FOCALDISTANCERIGHT, k_RixSCFloat ),
        RixSCParamInfo(US_FOCALDISTANCESPLIT, k_RixSCFloat ),
        
        RixSCParamInfo() // end of table
    };
    return &s_ptable[ 0 ];
}

RixProjection* WillPerspectiveFactory::CreateProjection(
    RixContext& ctx,
    RtUString const handle,
    RixParameterList const* pList)
{
    return new WillPerspective(ctx, handle, pList);
}

void WillPerspectiveFactory::DestroyProjection(RixProjection const* projection)
{
    delete (WillPerspective*)projection;
}

RIX_PROJECTIONFACTORYCREATE
{
    PIXAR_ARGUSED(hint);
    return new WillPerspectiveFactory();
}

RIX_PROJECTIONFACTORYDESTROY
{
    delete reinterpret_cast< WillPerspectiveFactory * >( factory );
}
