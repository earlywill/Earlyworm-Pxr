/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2019 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include <RixProjection.h>
#include <RixIntegrator.h>
#include <RixShadingUtils.h>
#include <RixInterfaces.h>

// This plugin reimplements the standard perspective projection.  It shows
// the details of turning screen and aperture samples into rays (complete
// with derivatives) that are exactly identical to those from the built-in
// perspective projection.  It's meant to provide a good base for tweaking.

const static RtUString US_ORTHOWIDTH("orthoWidth");
const static RtUString US_MODULO("modulo");
const static RtUString US_ALTVIEW("altView");
const static RtUString US_TOP("top");
const static RtUString US_SIDE("side");
const static RtUString US_FRONT("front");

class WillQuadView : public RixProjection
{
public:

    WillQuadView(
        RixContext& ctx,
        RtUString const handle,
        RixParameterList const* params);

    ~WillQuadView() override;

    void RenderBegin(RixContext& ctx, RixProjectionEnvironment const& env,
                     RixParameterList const* parms) override;

    RixSCDetail GetProperty(
        ProjectionProperty property,
        void const** result) const override
    {
        switch (property)
        {
            case k_DicingHint:
                *result = &dicingHint;
                return k_RixSCUniform;
                break;
            default:
                return k_RixSCInvalidDetail;
        }
    }

    void Project(
        RixProjectionContext& pCtx ) override;

private:

    DicingHint const dicingHint;
    RtUString m_handle;
    RtFloat orthoWidth;
    RtFloat modulo;
    RtFloat xyStep;
    RtMatrix4x4 altView;
    RtMatrix4x4 top;
    RtMatrix4x4 side;
    RtMatrix4x4 front;
    RtMatrix4x4 invview;
};


WillQuadView::WillQuadView(
    RixContext& ctx,
    RtUString const handle,
    RixParameterList const* params)
    : dicingHint(k_Orthographic),
      m_handle(handle)
{
    PIXAR_ARGUSED(ctx);
    PIXAR_ARGUSED(params);
}

void WillQuadView::RenderBegin(
    RixContext& ctx,
    RixProjectionEnvironment const& env,
    RixParameterList const* params)
{
    PIXAR_ARGUSED(ctx);
    PIXAR_ARGUSED(params);
   
    orthoWidth = 1.0f;
    modulo = 1.0f;
    altView = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
    top = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
    side = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
    front = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
    
    // world to camera
    const RtMatrix4x4* viewone = env.worldToCameraMatrix;
    // inverse matrix
    viewone->Inverse(&invview);
    
    //std::cout << "viewone" << std::endl;
    //std::cout << view << std::endl;
    //std::cout << "invview" << std::endl;
    //std::cout << invview << std::endl;
    
    RtInt paramId;
    if ( params->GetParamId(US_ORTHOWIDTH, &paramId ) == 0 )
        params->EvalParam( paramId, 0, &orthoWidth );
    if ( params->GetParamId(US_MODULO, &paramId ) == 0 )
        params->EvalParam( paramId, 0, &modulo );
    if ( params->GetParamId(US_ALTVIEW, &paramId ) == 0 )
        params->EvalParam( paramId, 0, &altView );
    if ( params->GetParamId(US_TOP, &paramId ) == 0 )
        params->EvalParam( paramId, 0, &top );
    if ( params->GetParamId(US_SIDE, &paramId ) == 0 )
        params->EvalParam( paramId, 0, &side );
    if ( params->GetParamId(US_FRONT, &paramId ) == 0 )
        params->EvalParam( paramId, 0, &front );
    
    //std::cout << "viewone" << std::endl;
    //std::cout << view << std::endl;
    //std::cout << "invview" << std::endl;
    //std::cout << invview << std::endl;
    //std::cout << "altview" << std::endl;
    //std::cout << altView << std::endl;
    
    float screenWidth = env.screenWindowRight - env.screenWindowLeft;
    float screenHeight = env.screenWindowTop - env.screenWindowBottom;
    if ( screenWidth == 0.0f || screenHeight == 0.0f )
    {
        float aspect = env.width * env.pixelAspectRatio / env.height;
        screenWidth = std::max( 2.0f, 2.0f * aspect );
        screenHeight = std::max( 2.0f, 2.0f / aspect );
    }
    screenWidth *= orthoWidth;
    screenHeight *= orthoWidth;
    float xStep = 0.25f * screenWidth / env.width;
    float yStep = 0.25f * screenHeight / env.height;
    xyStep = std::max( xStep, yStep );
    
    
}

WillQuadView::~WillQuadView()
{
}

void WillQuadView::Project(
    RixProjectionContext& pCtx )
{
    for ( int index = 0; index < pCtx.numRays; ++index )
    {
        RtPoint2 const& screen( pCtx.screen[ index ] );
        //RtPoint2 const& aperture( pCtx.aperture[ index ] );
        RtRayGeometry& ray( pCtx.rays[ index ] );
        
        ray.direction = RtVector3(
            0.0f,
            0.0f,
            1.0f );
            
        if (screen.x < 0.0f && screen.y > 0.0f) // top-left
        {
            
            // grab original origin
            RtPoint3 origO = RtPoint3(
                screen.x,
                screen.y,
                0.0f );
             
            //std::cout << "origO start" << std::endl;
            //std::cout << origO << std::endl;

            
            RtPoint3 projO = RtPoint3(
                (screen.x - -0.5f) * orthoWidth,
                (screen.y - 0.5f) * orthoWidth,
                0.0f );
                
            //std::cout << "projO start" << std::endl;
            //std::cout << projO << std::endl;
            
            // direction
            RtVector3 projD = RtVector3(
                    0.0f,
                    0.0f,
                    1.0f );
            
            // camera to world
            projD = invview.vTransform(projD);
            projO = invview.vTransform(projO);
            origO = invview.pTransform(origO);
            
            // setup orthographic view
            //RtPoint3 projO = RtPoint3(
            //    (origO.x - -0.5f) * orthoWidth,
            //    (origO.y - 0.5f) * orthoWidth,
            //    0.0f );
            
            // world to parameter defined space
            projD = altView.vTransform(projD);
            projO = altView.vTransform(projO);
            origO = altView.pTransform(origO); 
            
            origO.x = (origO.x - -0.5f) * orthoWidth;
            origO.y = (origO.y - 0.5f) * orthoWidth;
            
            //std::cout << "origO end" << std::endl;
            //std::cout << origO << std::endl;
            
            //std::cout << "projO end" << std::endl;
            //std::cout << projO << std::endl;
                            
            ray.origin = projO;
            ray.direction = projD;            
        }
        else if (screen.x > 0.0f && screen.y > 0.0f) // top-right
        {
            RtPoint3 projO = RtPoint3(
                (screen.x - 0.5f) * orthoWidth,
                (screen.y - 0.5f) * orthoWidth,
                0.0f );
            RtVector3 projD = RtVector3(
                    0.0f,
                    0.0f,
                    1.0f );
            projD = top.vTransform(projD);
            projO = top.pTransform(projO);     
            ray.origin = projO;
            ray.direction = projD; 
            
            // offset screen.xy and scale by orthographic width
            // possible need to also pre-scale screen.xy as well?
            //ray.origin = RtPoint3(
            //    (screen.x - 0.5f) * orthoWidth,
            //    (screen.y - 0.5f) * orthoWidth,
            //    0.0f );
        }
        else if (screen.x < 0.0f && screen.y < 0.0f) // bottom-left
        {
            RtPoint3 projO = RtPoint3(
                (screen.x - -0.5f) * orthoWidth,
                (screen.y - -0.5f) * orthoWidth,
                0.0f );
            RtVector3 projD = RtVector3(
                    0.0f,
                    0.0f,
                    1.0f );
            projD = side.vTransform(projD);
            projO = side.pTransform(projO);     
            ray.origin = projO;
            ray.direction = projD; 
            //ray.origin = RtPoint3(
            //    (screen.x - -0.5f) * orthoWidth,
            //    (screen.y - -0.5f) * orthoWidth,
            //    0.0f );    
        }
        else if (screen.x > 0.0f && screen.y < 0.0f) // bottom-right
        {
            RtPoint3 projO = RtPoint3(
                (screen.x - 0.5f) * orthoWidth,
                (screen.y - -0.5f) * orthoWidth,
                0.0f );
            RtVector3 projD = RtVector3(
                    0.0f,
                    0.0f,
                    1.0f );
            projD = front.vTransform(projD);
            projO = front.pTransform(projO);     
            ray.origin = projO;
            ray.direction = projD; 
            
            //ray.origin = RtPoint3(
            //    (screen.x - 0.5f) * orthoWidth,
            //    (screen.y - -0.5f) * orthoWidth,
            //    0.0f );    
        }
        else // any other possible conditions??
        {
            RtPoint3 projO = RtPoint3(
                screen.x * 1.f,
                screen.y * 1.f,
                0.0f );
            RtVector3 projD = RtVector3(
                    0.0f,
                    0.0f,
                    1.0f );
            projD = top.vTransform(projD);
            projO = top.pTransform(projO);     
            ray.origin = projO;
            ray.direction = projD; 
            
            //ray.origin = RtPoint3(
            //    screen.x * 1.f,
            //    screen.y * 1.f,
            //    0.0f );
        }
            
        
        ray.direction.Normalize();
        ray.originRadius = xyStep;
        ray.raySpread = 0.0f;
    }
}

// ===============================================================

class WillQuadViewFactory : public RixProjectionFactory
{
public:

    WillQuadViewFactory() {};

    int Init(RixContext& ctx, RtUString const pluginPath) override
    {
        PIXAR_ARGUSED(ctx);
        PIXAR_ARGUSED(pluginPath);

        return 0;
    }

    void Finalize(RixContext& ctx) override
    {
        PIXAR_ARGUSED(ctx);
    }

    RixSCParamInfo const* GetParamTable() override;

    void Synchronize(
        RixContext &ctx,
        RixSCSyncMsg syncMsg,
        RixParameterList const *parameterList) override
    {
        PIXAR_ARGUSED(ctx);
        PIXAR_ARGUSED(syncMsg);
        PIXAR_ARGUSED(parameterList);
    }

    RixProjection* CreateProjection(
        RixContext& ctx,
        RtUString const handle,
        RixParameterList const* pList) override;

    void DestroyProjection(RixProjection const* projection) override;
};


RixSCParamInfo const* WillQuadViewFactory::GetParamTable()
{
    static RixSCParamInfo s_ptable[] =
    {
        // orthographic camera has one parameters
        RixSCParamInfo(US_ORTHOWIDTH, k_RixSCFloat ),
        RixSCParamInfo(US_MODULO, k_RixSCFloat ),
        RixSCParamInfo(US_ALTVIEW, k_RixSCMatrix ),
        RixSCParamInfo(US_TOP, k_RixSCMatrix ),
        RixSCParamInfo(US_SIDE, k_RixSCMatrix ),
        RixSCParamInfo(US_FRONT, k_RixSCMatrix ),
        RixSCParamInfo() // end of table
    };
    return &s_ptable[ 0 ];
}

RixProjection* WillQuadViewFactory::CreateProjection(
    RixContext& ctx,
    RtUString const handle,
    RixParameterList const* pList)
{
    return new WillQuadView(ctx, handle, pList);
}

void WillQuadViewFactory::DestroyProjection(RixProjection const* projection)
{
    delete (WillQuadView*)projection;
}

RIX_PROJECTIONFACTORYCREATE
{
    PIXAR_ARGUSED(hint);
    return new WillQuadViewFactory();
}

RIX_PROJECTIONFACTORYDESTROY
{
    delete reinterpret_cast< WillQuadViewFactory * >( factory );
}
