/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2018 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

//GoPro Virtual Lens Repoint 360 is licensed under either:

//Apache License, Version 2.0, (http://www.apache.org/licenses/LICENSE-2.0)
//MIT license (http://opensource.org/licenses/MIT)
//at your option.

//Copyright 2019 GoPro, Inc.

//Permission is hereby granted, free of charge, to any person obtaining a 
//copy of this software and associated documentation files (the "Software"), 
//to deal in the Software without restriction, including without limitation 
//the rights to use, copy, modify, merge, publish, distribute, sublicense, 
//and/or sell copies of the Software, and to permit persons to whom the 
//Software is furnished to do so, subject to the following conditions:

//The above copyright notice and this permission notice shall be included 
//in all copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
//OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
//THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
//DEALINGS IN THE SOFTWARE.

#include "RixProjection.h"
#include "RixIntegrator.h"
#include "RixInterfaces.h"

#include <algorithm>
#include <cstring>

const static RtUString US_PRIM("primary");
const static RtUString US_SEC("secondary");
const static RtUString US_LOOK("look");
const static RtUString US_TERT("tertiary");
const static RtUString US_MAXR("maxradius");

class WillActionCam : public RixProjection
{
public:

    WillActionCam(
        RixContext &ctx,
        RtUString const handle,
        RixParameterList const* parm);
    
    ~WillActionCam() override;
    
    void RenderBegin(RixContext& ctx, RixProjectionEnvironment const& env,
                 RixParameterList const* parm) override;

    RixSCDetail GetProperty(
        ProjectionProperty property,
        void const** result) const override
    {
        switch (property)
        {
            case k_DicingHint:
                *result = &dicingHint;
                return k_RixSCUniform;
                break;
            default:
                return k_RixSCInvalidDetail;
        }
    }
    
    void Project(RixProjectionContext& pCtx) override;

private:

    DicingHint const dicingHint;
    RtFloat const fovHint;
    RtUString m_handle;
    RtFloat xyStep;
    RtFloat spread;
    RtFloat primary;
    RtFloat secondary;
    RtInt look;
    RtFloat tertiary;
    RtFloat maxradius;
    
};

WillActionCam::WillActionCam(
    RixContext& ctx,
    RtUString const handle,
    RixParameterList const* params)
    : dicingHint(k_Perspective),
      fovHint(170.0f),
      m_handle(handle)
{
    PIXAR_ARGUSED(ctx);
    PIXAR_ARGUSED(params);
}

void WillActionCam::RenderBegin(
    RixContext& ctx,
    RixProjectionEnvironment const& env,
    RixParameterList const* parms)
{
    PIXAR_ARGUSED(ctx);
    PIXAR_ARGUSED(parms);

    float screenWidth = env.screenWindowRight - env.screenWindowLeft;
    float screenHeight = env.screenWindowTop - env.screenWindowBottom;
    if ( screenWidth == 0.0f || screenHeight == 0.0f )
    {
        float aspect = env.width * env.pixelAspectRatio / env.height;
        screenWidth = std::max( 2.0f, 2.0f * aspect );
        screenHeight = std::max( 2.0f, 2.0f / aspect );
    }
    
    //fieldOfView = 180.0f;
    primary = 85.6f;
    secondary = 10.91f;
    tertiary = 1.31f;
    look = 1;
    maxradius = 1.25f;
    
    RtInt paramId;
    if ( parms->GetParamId(US_PRIM, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &primary );
    if ( parms->GetParamId(US_SEC, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &secondary );
    if ( parms->GetParamId(US_LOOK, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &look );
    if ( parms->GetParamId(US_TERT, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &tertiary );
    if ( parms->GetParamId(US_MAXR, &paramId ) == 0 )
        parms->EvalParam( paramId, 0, &maxradius );
    
    float xStep = 0.25f * screenWidth / env.width;
    float yStep = 0.25f * screenHeight / env.height;
    xyStep = std::max( xStep, yStep );
    spread =  2.0f * (F_PI * 0.5) * xyStep;
    //maxradius = maxradius * env.width * 0.5f;

}

WillActionCam::~WillActionCam()
{
}


void WillActionCam::Project(RixProjectionContext& pCtx)
{
    for ( int index = 0; index < pCtx.numRays; ++index )
    {
        RtPoint2 const& screen( pCtx.screen[ index ] );
        RtRayGeometry &ray( pCtx.rays[ index ] );
        
        ray.origin = RtFloat3( 0.0f, 0.0f, 0.0f );
        ray.originRadius = 0.0f;
        
        float theta = atan2 (screen.y, screen.x);
        float radius = sqrtf(screen.x * screen.x + screen.y * screen.y);
        //radius = radius / maxradius;
        float phi = (radius * primary - radius * radius * secondary) * F_PI / 180.0;
        if (look < 1) // non GoPro look
        {
            phi = atan(radius / tertiary) * 2.0;
        }
        
        if (radius < 0.0f)
        {
            ray.direction = RtFloat3( 0.0f, 0.0f, 0.0f );
            continue;
        }
        
        ray.direction = RtFloat3(
            sin(phi) * cos(theta),
            sin(phi) * sin(theta),
            cos(phi));

        ray.raySpread = spread;
        
    }
}

// ===============================================================

class WillActionCamFactory : public RixProjectionFactory
{
public:

    WillActionCamFactory() {};

    int Init(RixContext& ctx, RtUString const pluginPath) override
    {
        PIXAR_ARGUSED(ctx);
        PIXAR_ARGUSED(pluginPath);

        return 0;
    }

    void Finalize(RixContext& ctx) override
    {
        PIXAR_ARGUSED(ctx);
    }

    RixSCParamInfo const* GetParamTable() override;

    void Synchronize(
        RixContext&,
        RixSCSyncMsg,
        RixParameterList const*) override
    {
    }

    RixProjection* CreateProjection(
        RixContext& ctx,
        RtUString const handle,
        RixParameterList const* pList) override;

    void DestroyProjection(RixProjection const* projection) override;
};


RixSCParamInfo const* WillActionCamFactory::GetParamTable()
{
    static RixSCParamInfo s_ptable[] =
    {
        RixSCParamInfo( US_PRIM, k_RixSCFloat ),
        RixSCParamInfo( US_SEC, k_RixSCFloat ),
        RixSCParamInfo( US_LOOK, k_RixSCInteger ),
        RixSCParamInfo( US_TERT, k_RixSCFloat ),
        RixSCParamInfo( US_MAXR, k_RixSCFloat ),
        RixSCParamInfo() // end of table
    };
    return &s_ptable[ 0 ];
}

RixProjection* WillActionCamFactory::CreateProjection(
    RixContext& ctx,
    RtUString const handle,
    RixParameterList const* pList)
{
    return new WillActionCam(ctx, handle, pList);
}

void WillActionCamFactory::DestroyProjection(RixProjection const* projection)
{
    delete (WillActionCam*)projection;
}

RIX_PROJECTIONFACTORYCREATE
{
    PIXAR_ARGUSED(hint);
    return new WillActionCamFactory();
}

RIX_PROJECTIONFACTORYDESTROY
{
    delete reinterpret_cast< WillActionCamFactory * >( factory );
}
